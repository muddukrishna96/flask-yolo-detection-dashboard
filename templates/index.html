{% extends "base.html" %}

{% block title %} Dashboard {% endblock %} 

<!-- Element injected in the BODY element -->
{% block body_class %} sidebar-mini {% endblock body_class %} 

<!-- Specific Page CSS goes HERE  -->
{% block stylesheets %}

  <!-- Google Font: Source Sans Pro -->
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:300,400,400i,700&display=fallback">
  <!-- Font Awesome -->
  <link rel="stylesheet" href="/static/assets/plugins/fontawesome-free/css/all.min.css">
  <!-- Ionicons -->
  <link rel="stylesheet" href="https://code.ionicframework.com/ionicons/2.0.1/css/ionicons.min.css">
  <!-- Tempusdominus Bootstrap 4 -->
  <link rel="stylesheet" href="/static/assets/plugins/tempusdominus-bootstrap-4/css/tempusdominus-bootstrap-4.min.css">
  <!-- iCheck -->
  <link rel="stylesheet" href="/static/assets/plugins/icheck-bootstrap/icheck-bootstrap.min.css">
  <!-- JQVMap -->
  <link rel="stylesheet" href="/static/assets/plugins/jqvmap/jqvmap.min.css">
  <!-- Theme style -->
  <link rel="stylesheet" href="/static/assets/css/adminlte.min.css">
  <!-- Custom overrides and color theme -->
  <link rel="stylesheet" href="/static/assets/css/custom.css">
  <!-- Intro.js for guided tours -->
  <link rel="stylesheet" href="https://unpkg.com/intro.js/minified/introjs.min.css">
  <!-- overlayScrollbars -->
  <link rel="stylesheet" href="/static/assets/plugins/overlayScrollbars/css/OverlayScrollbars.min.css">
  <!-- Daterange picker -->
  <link rel="stylesheet" href="/static/assets/plugins/daterangepicker/daterangepicker.css">
  <!-- summernote -->
  <link rel="stylesheet" href="/static/assets/plugins/summernote/summernote-bs4.min.css">

  <!-- Custom styles are in static/assets/css/custom.css -->

{% endblock stylesheets %}

{% block content %}
  
  <div class="content-wrapper">

    <!-- Home view: shown on initial load -->
    <div id="home-view" style="display:block; padding:60px 0; text-align:center;">
      <img src="/static/assets/logo.png" alt="Logo" style="width:320px; max-width:80%; height:auto; display:block; margin:0 auto 18px;">
      <h2 style="font-weight:600; color:#333;">Welcome to the AI Dashboard</h2>
      <p class="text-muted">Select a task from the sidebar to get started.</p>
      <div style="max-width:900px; margin:18px auto 0; text-align:left;">
        <h4 style="font-weight:600; color:#4f7382;">Vision</h4>
        <p style="color:#333; font-size:1rem; line-height:1.4;">Our vision is to create a free, open-source, and universally accessible inference dashboard that streamlines the way computer vision teams develop, test, and validate their models. We aim to eliminate unnecessary complexity, reduce engineering overhead, and accelerate innovation by providing a unified platform where users can effortlessly upload, run, and compare models across multiple input sources ,images, videos, single or multi-camera feeds in real time.</p>
        <p style="color:#555; font-size:0.95rem; margin-top:8px;">This platform provides tooling and a common UI for experimentation and validation. It is not intended to claim ownership of third-party model weights: the models available for users are provided by their respective authors (for example, Ultralytics) and remain those authors' property.</p>
        <!-- Important phase note -->
        <div class="alert alert-warning" role="alert" style="margin-top:14px; border-left:4px solid #d39e00; background:#fff3cd; color:#856404;">
          <h5 style="margin-top:0; margin-bottom:6px; font-weight:600;">Important</h5>
          <p style="margin:0; line-height:1.4;">This dashboard is currently under construction and features are rolled out in phases. Phase 1 supports only YOLO models v8 and above in <code>.pt</code> format as officially supported inputs. Other model formats or versions may be uploaded, but results could be unreliable or unexpected. Please treat this platform as a development/testing tool and verify results carefully.</p>
        </div>
      </div>
    </div>

    <!-- Contact page view: replaces the modal when user clicks Contact in the top nav -->
    <div id="contact-view" style="display:none; padding:40px 0; text-align:center;">
      <div style="max-width:720px; margin:0 auto; text-align:left;">
        <div class="card">
          <div class="card-body d-flex align-items-start">
            <img src="/static/assets/photo.jpg" alt="Photo" style="width:96px; height:96px; object-fit:cover; margin-right:16px;" class="rounded-circle">
            <div>
              <h3 style="margin:0 0 6px 0;">muddu krishna galavalli</h3>
              <p style="margin:0 0 6px 0; color:#666;">AI / Computer Vision</p>
              <p style="margin:6px 0;"><strong>Phone:</strong> <a href="tel:+4915906133210">+49 15906133210</a></p>
              <p style="margin:6px 0;"><strong>Email:</strong> <a href="mailto:galavallimuddukrishna@gmail.com">galavallimuddukrishna@gmail.com</a></p>
              <p style="margin:6px 0;">Links:
                <a href="https://www.linkedin.com/in/galavalli-muddu-krishna-bb87ba112/" target="_blank" rel="noopener" class="ml-2"><i class="fab fa-linkedin"></i> LinkedIn</a>
                <a href="https://github.com/muddukrishna96" target="_blank" rel="noopener" class="ml-3"><i class="fab fa-github"></i> GitHub</a>
              </div>
            </div>
          </div>

          <p style="margin:8px 0 0 0; line-height:1.45; font-size:0.95rem;">I bring a rare combination of deep technical expertise and strong project leadership. I&rsquo;ve architected multi-camera, real-time inspection systems that process over 3,000 units a day, delivered cloud-based inference pipelines with sub-2-second latency, and achieved industry-leading accuracy on mission-critical tasks like surgical screw identification and quality control automation. My work consistently bridges the gap between research and real-world deployment, ensuring AI systems are not just cutting-edge but reliable, scalable, and factory-ready.</p>
      </div>
    </div>

    <!-- Detection dashboard: hidden until user selects Object detection task -->
    <div id="detection-dashboard" style="display:none;">

      <!-- Message shown when a selected task is not yet implemented -->
      <div id="task-unavailable" style="display:none; padding:60px 0; text-align:center;">
        <div class="card mx-auto" style="max-width:720px;">
          <div class="card-body">
            <h4 class="card-title">Feature coming soon</h4>
            <p class="card-text">The <strong id="unavailable-task-name">selected</strong> feature is under development and will be available in a future release. For now, only the Object detection dashboard is available.</p>
            <button id="unavailable-ok" class="btn btn-primary">OK</button>
          </div>
        </div>
      </div>

      <div id="detection-content">

    <!-- Content Header (Page header) -->
    <div class="content-header">
      <div class="container-fluid">
        <div class="row mb-2">
          <div class="col-sm-6">
            <h1 class="m-0 text-dark">AI results Dashboard</h1>
          </div><!-- /.col -->
          <div class="col-sm-6 text-right">
            <!-- Persistent help button to start tour manually -->
            <button id="tour-help-btn" class="btn btn-sm" title="Take a quick tour">Take Tour</button>
          </div>
          <div class="col-sm-6">
            <ol class="breadcrumb float-sm-right">
              <li class="breadcrumb-item"><a href="index.html">Home</a></li>
              <li class="breadcrumb-item active">View Detected Image</li>
            </ol>
          </div><!-- /.col -->
        </div><!-- /.row -->
      </div><!-- /.container-fluid -->
    </div>
    <!-- /.content-header -->

    <!-- Small ephemeral toast to remind about the tour (shown if user previously saw tour) -->
    <div id="tour-toast">
      <div class="toast-inner">
        <div class="msg">Need a quick tour?</div>
        <div class="actions">
          <button id="tour-toast-start" class="btn btn-sm btn-primary">Start</button>
          <button id="tour-toast-dismiss" class="btn btn-sm btn-outline-secondary">Dismiss</button>
        </div>
      </div>
    </div>

    <!-- Main content -->
    <section class="content">
      <div class="container-fluid">
        <!-- Small boxes (Stat box) -->
         <div class="row">
       
          <!-- ./col -->
        </div>
        
		<!-- /.row -->
        <!-- Main row -->
        <div class="row">
          <!-- Left col -->
          <section class="col-lg-6 connectedSortable">
            <!-- Custom tabs (Charts with tabs)-->
            <div class="card">
              <div class="card-header">
                <h3 class="card-title">
                  <i class="fas fa-chart-pie mr-1"></i>
                  Upload or Stream for AI Processing
                </h3>
				
                
              </div><!-- /.card-header -->
              <div class="card-body" style="overflow: visible;">
                <div class="tab-content p-0">
                  <!-- Morris chart - Sales -->
      <div class="chart tab-pane active" id="revenue-chart"
        style="position: relative; overflow: visible;">
            
			<!-- AI code - LEFT PANEL VISIBLE WORKFLOW -->

  		<form id="predict-form" class="form-signin col-lg-12" method="post" enctype="multipart/form-data" name="form1">
    <input type="hidden" name="task" id="selected-task-input" value="{{ selected_task or 'detection' }}">

  <div style="max-width:100%; margin:auto; text-align:left; padding:12px 8px;">
    <h4 class="h5 mb-2 font-weight-normal">1) Select Model</h4>
    {% if message %}
      <div class="alert alert-warning" role="alert" style="margin-top:8px;">{{ message }}</div>
    {% endif %}

    <!-- Visible list of built-in models as radio buttons (not a dropdown) -->
  <div id="model-list" class="mb-2" style="max-height:140px; overflow:auto; border:1px solid #eee; padding:6px;">
      {% for m in models %}
      <div class="form-check" data-model="{{ m }}">
        <input class="form-check-input" type="radio" name="model" id="model_{{ loop.index }}" value="{{ m }}" {% if selected_model==m %}checked{% endif %}>
        <label class="form-check-label small" for="model_{{ loop.index }}">{{ m }} <span class="model-badge">{{ m[:12] }}</span></label>
      </div>
      {% endfor %}
    </div>

    <div class="mb-3 small text-muted">Or upload a custom .pt model (kept in memory only)</div>
    <div style="border:1px dashed #ddd; padding:8px; border-radius:6px; margin-bottom:8px;">
      <div class="form-row align-items-center">
        <div class="col-6">
          <input type="file" class="form-control-file" id="model_file" accept=".pt">
        </div>
        <div class="col-4">
          <input type="text" class="form-control form-control-sm" id="model_name" placeholder="Display name (optional)">
        </div>
        <div class="col-2">
          <button type="button" id="upload-model-submit" class="btn btn-sm btn-primary">Upload</button>
        </div>
      </div>
      <div class="form-check mt-2">
        <input class="form-check-input" type="checkbox" id="disclaimer_inline">
        <label class="form-check-label small" for="disclaimer_inline">I confirm I have rights to this model</label>
      </div>
    </div>

    <!-- First-time tour prompt (shows only when localStorage flag not set) -->
    <div id="tour-prompt" style="display:none;" role="dialog" aria-hidden="true">
      <div class="tour-prompt-inner">
        <div class="tour-text">Welcome! Would you like a quick tour of the dashboard?</div>
        <div class="tour-actions">
          <button id="tour-start" class="btn btn-sm btn-primary">Start Tour</button>
          <button id="tour-skip" class="btn btn-sm btn-outline-secondary">Skip</button>
        </div>
      </div>
    </div>

    <hr/>

    <h4 class="h5 mb-2 font-weight-normal">2) Choose Input</h4>
    <div class="mb-2">
      <div class="form-check form-check-inline">
        <input class="form-check-input" type="radio" name="inputType" id="input-image" value="image">
        <label class="form-check-label small" for="input-image">Image</label>
      </div>
      <div class="form-check form-check-inline">
        <input class="form-check-input" type="radio" name="inputType" id="input-video" value="video">
        <label class="form-check-label small" for="input-video">Video</label>
      </div>
      <div class="form-check form-check-inline">
        <input class="form-check-input" type="radio" name="inputType" id="input-webcam" value="webcam">
        <label class="form-check-label small" for="input-webcam">Webcam</label>
      </div>
    </div>

    <!-- File input (Image/Video) - visible but disabled until relevant option chosen -->
    <div id="file-input-area" class="mb-2" style="display:none;">
      <div class="small text-muted" id="file-input-hint" style="display:none; margin-bottom:4px;"></div>
      <input type="file" name="file" class="form-control-file" id="inputfile" disabled
            accept="image/png,image/jpeg,image/jpg,image/bmp,image/gif,image/webp,video/mp4,video/avi,video/quicktime,video/x-matroska,video/x-flv,video/x-ms-wmv">
    </div>

    <!-- Webcam options - visible but controls disabled until Webcam selected -->
    <div id="webcam-options-area" class="mb-2" style="border:1px solid #f1f1f1; padding:8px; border-radius:6px; display:none;">
      <div class="form-group">
        <label class="small">Camera mode</label>
        <div>
          <div class="form-check form-check-inline">
            <input class="form-check-input" type="radio" name="camera_mode" id="camera-single" value="single" checked>
            <label class="form-check-label small" for="camera-single">Single</label>
          </div>
          <div class="form-check form-check-inline">
            <input class="form-check-input" type="radio" name="camera_mode" id="camera-dual" value="dual">
            <label class="form-check-label small" for="camera-dual">Dual</label>
          </div>
          <div class="form-check form-check-inline">
            <input class="form-check-input" type="checkbox" id="single_split_mode" />
            <label class="form-check-label small" for="single_split_mode">Process single camera with two models (stacked)</label>
          </div>
        </div>
      </div>

      <div id="webcam-models-single" style="margin-bottom:6px;">
        <div class="small text-muted">Camera 0 model</div>
        <div style="max-height:100px; overflow:auto; border:1px solid #eee; padding:6px;">
          {% for m in models %}
          <div class="form-check" data-model="{{ m }}">
            <input class="form-check-input" type="radio" name="single_model" id="single_{{ loop.index }}" value="{{ m }}" {% if selected_model==m %}checked{% endif %}>
            <label class="form-check-label small" for="single_{{ loop.index }}">{{ m }} <span class="model-badge">{{ m[:12] }}</span></label>
          </div>
          {% endfor %}
        </div>
      </div>

      <div id="webcam-models-dual" style="display:none;">
        <div class="small text-muted">Camera 0 model</div>
        <div style="max-height:80px; overflow:auto; border:1px solid #eee; padding:6px; margin-bottom:6px;">
          {% for m in models %}
          <div class="form-check" data-model="{{ m }}">
            <input class="form-check-input" type="radio" name="dual_model0" id="d0_{{ loop.index }}" value="{{ m }}" {% if selected_model==m %}checked{% endif %}>
            <label class="form-check-label small" for="d0_{{ loop.index }}">{{ m }} <span class="model-badge">{{ m[:12] }}</span></label>
          </div>
          {% endfor %}
        </div>
        <div class="small text-muted">Camera 1 model</div>
        <div style="max-height:80px; overflow:auto; border:1px solid #eee; padding:6px;">
          {% for m in models %}
          <div class="form-check" data-model="{{ m }}">
            <input class="form-check-input" type="radio" name="dual_model1" id="d1_{{ loop.index }}" value="{{ m }}" {% if selected_model==m %}checked{% endif %}>
            <label class="form-check-label small" for="d1_{{ loop.index }}">{{ m }} <span class="model-badge">{{ m[:12] }}</span></label>
          </div>
          {% endfor %}
        </div>
      </div>

      <div class="form-group">
        <div style="display:flex; align-items:center; gap:8px;">
          <label class="small" style="margin:0;">Capture scale</label>
          <button type="button" class="btn btn-sm btn-link p-0" style="font-size:16px;" data-toggle="tooltip" title="Reduces camera resolution for faster inference. Lower scale = faster processing but smaller image. Server upscales output for display.">
            <i class="fa fa-info-circle text-muted"></i>
          </button>
        </div>
        <div>
          <select id="webrtc-capture-scale" class="form-control form-control-sm" style="max-width:180px;">
            <option value="1.0">100%</option>
            <option value="0.75">75%</option>
            <option value="0.5">50%</option>
          </select>
        </div>
      </div>

      <!-- Camera index selection modal (used when multiple cameras detected) -->
      <div id="camera-index-modal" class="modal" tabindex="-1" role="dialog" style="display:none;">
        <div class="modal-dialog" role="document">
          <div class="modal-content">
            <div class="modal-header">
              <h5 class="modal-title">Select Camera</h5>
            </div>
            <div class="modal-body" id="camera-index-body">
              <p id="camera-index-instructions">Multiple cameras detected. Choose which camera to use:</p>
              <div id="camera-index-list"></div>
            </div>
            <div class="modal-footer">
              <button type="button" id="camera-index-choose" class="btn btn-primary">Use selected</button>
              <button type="button" id="camera-index-cancel" class="btn btn-secondary">Cancel</button>
            </div>
          </div>
        </div>
      </div>

          <!-- Contact modal -->
          <div id="contact-modal" class="modal fade" tabindex="-1" role="dialog" aria-hidden="true">
            <div class="modal-dialog modal-sm" role="document">
              <div class="modal-content">
                <div class="modal-header d-flex align-items-center">
                  <img src="/static/assets/photo.jpg" alt="Photo" style="width:64px; height:64px; object-fit:cover; margin-right:12px;" class="rounded-circle">
                  <div style="flex:1 1 auto;">
                    <h5 class="modal-title mb-0">muddu krishna galavalli</h5>
                    <small class="text-muted">AI / Computer Vision</small>
                  </div>
                  <button type="button" class="close" data-dismiss="modal" aria-label="Close">
                    <span aria-hidden="true">&times;</span>
                  </button>
                </div>
                <div class="modal-body">
                  <p><strong>Phone:</strong> <a href="tel:+49 15906133210">+49 15906133210</a></p>
                  <p class="mb-1"><strong>Links:</strong></p>
                  <p>
                    <a href="https://www.linkedin.com/in/galavalli-muddu-krishna-bb87ba112/" target="_blank" rel="noopener" class="mr-2"><i class="fab fa-linkedin fa-lg"></i> LinkedIn</a>
                    <a href="https://github.com/muddukrishna96?tab=repositories" target="_blank" rel="noopener"><i class="fab fa-github fa-lg"></i> GitHub</a>
                  </p>
                </div>
                <div class="modal-footer">
                  <button type="button" class="btn btn-secondary" data-dismiss="modal">Close</button>
                </div>
              </div>
            </div>
          </div>

              <!-- WebRTC error modal -->
              <div class="modal fade" id="webrtc-error-modal" tabindex="-1" role="dialog" aria-labelledby="webrtc-error-title" aria-hidden="true">
                <div class="modal-dialog" role="document">
                  <div class="modal-content">
                    <div class="modal-header bg-danger text-white">
                      <h5 class="modal-title" id="webrtc-error-title">WebRTC Stream Error</h5>
                      <button type="button" class="close text-white" data-dismiss="modal" aria-label="Close">
                        <span aria-hidden="true">&times;</span>
                      </button>
                    </div>
                    <div class="modal-body">
                      <p id="webrtc-error-message" class="mb-0">An unexpected error occurred while starting the WebRTC stream.</p>
                    </div>
                    <div class="modal-footer">
                      <button type="button" class="btn btn-secondary" data-dismiss="modal">Close</button>
                    </div>
                  </div>
                </div>
              </div>

      </div>
      <!-- Sticky action bar so Start/Predict are always visible -->
      <div class="left-actions">
        <div class="d-flex flex-column">
          <button type="button" id="start-webcam-inline" class="btn btn-primary btn-sm mb-2" disabled>Start Webcam</button>
          <button class="btn btn-secondary btn-block" id="predict-btn" type="submit" disabled>Predict</button>
        </div>
      </div>
    </div>

  

<!-- AI code - LEFT PANEL END -->

	
	
	

                 
                </div>
              </div><!-- /.card-body -->
            </div>
            <!-- /.card -->

            
      
          </section>
		  
		  
		            <section class="col-lg-6 connectedSortable">
            <!-- Custom tabs (Charts with tabs)-->
            <div class="card">
              <div class="card-header">
                <h3 class="card-title">
                  <i class="fas fa-chart-pie mr-1"></i>
                  YOLO {% if selected_task == 'segmentation' %}Segmentation{% elif selected_task == 'pose' %}Pose{% else %}Object Detection{% endif %} Results
                </h3>
				
                
              </div><!-- /.card-header -->
              <div class="card-body">
                <div class="tab-content p-0">
                  <!-- Morris chart - Sales -->
      <div class="chart tab-pane active" id="revenue-chart"
        style="position: relative;">
            
			<!-- AI code-->



<!-- Result display area (WebRTC video streams only) -->
<div class="right-result-container" style="width:100%; display:flex; flex-direction:column; gap:12px; overflow:visible;">
  <!-- Primary WebRTC stream (single camera or first dual camera feed) -->
  <video id="webrtc-remote" playsinline autoplay muted style="width:100%; height:auto; display:none; object-fit:contain; border:1px solid #ddd; border-radius:4px; background:transparent;"></video>
  <!-- Secondary WebRTC stream (used only for dual camera mode) -->
  <video id="webrtc-remote-secondary" playsinline autoplay muted style="width:100%; height:auto; display:none; object-fit:contain; border:1px solid #ddd; border-radius:4px; background:transparent;"></video>
  <!-- Processed image result display -->
  <img id="result-display" style="width:100%; height:auto; display:none; object-fit:contain; border:1px solid #ddd; border-radius:4px;">
  <!-- Real-time streaming video display (MJPEG stream) -->
  <img id="result-stream-display" style="width:100%; height:auto; display:none; object-fit:contain; border:1px solid #ddd; border-radius:4px;">
  <!-- Processed video result display -->
  <video id="result-video-display" controls style="width:100%; height:auto; display:none; object-fit:contain; border:1px solid #ddd; border-radius:4px;">
    <source id="result-video-source" src="" type="video/mp4">
    Your browser does not support the video tag.
  </video>
  <!-- Loading spinner shown while server is processing -->
  <div id="result-spinner" style="display:none; margin-top:16px;">
    <div class="spinner-border text-primary" role="status" style="width:3rem; height:3rem;">
      <span class="sr-only">Loading...</span>
    </div>
    <div id="spinner-text" style="margin-top:8px; font-weight:500;">Processing, please wait...</div>
  </div>
  <div id="webrtc-inline-status" class="alert alert-info" style="display:none; margin-top:12px;"></div>
  <div style="margin-top:8px; text-align:center;">
    <button type="button" id="stop-btn" class="btn btn-danger btn-sm" style="display:none;">Close</button>
  </div>
</div>

<script type="application/json" id="server-context-data">
  {{ {
    'image_url': image_url | default('', true),
    'video_present': video_present | default(false, true),
    'video_folder': video_folder | default('', true),
    'video_stream_url': video_stream_url | default('', true),
    'selected_task': selected_task | default('detection', true),
    'selected_model': selected_model | default('yolov8n.pt', true)
  }|tojson }}
</script>

<script>
// Server-provided processed outputs (empty string if none)
var serverContextElement = document.getElementById('server-context-data');
var serverContext = {};
if (serverContextElement) {
  try {
    serverContext = JSON.parse(serverContextElement.textContent || '{}');
  } catch (err) {
    console.warn('Unable to parse server context data:', err);
  }
}
var server_image_url = serverContext.image_url || '';
var server_video_present = !!serverContext.video_present;
var server_video_folder = serverContext.video_folder || '';
var server_video_stream_url = serverContext.video_stream_url || '';
var currentTask = serverContext.selected_task || 'detection';
var fallbackModels = { detection: 'yolov8n.pt', segmentation: 'yolo11n-seg.pt', pose: 'yolov8n-pose.pt' };
var currentModel = serverContext.selected_model || fallbackModels[currentTask] || fallbackModels.detection;

var webrtcManager = {
  sessions: [],
  add: function(session) {
    this.sessions.push(session);
  },
  remove: function(session) {
    var idx = this.sessions.indexOf(session);
    if (idx !== -1) {
      this.sessions.splice(idx, 1);
    }
  },
  closeAll: function(hideVideo) {
    var active = this.sessions.slice();
    active.forEach(function(session) {
      closeWebRTCSingleSession(session, hideVideo);
    });
    this.sessions = [];
  }
};

function syncTaskState(taskValue) {
  currentTask = taskValue || currentTask || 'detection';
  var hiddenTaskField = document.getElementById('selected-task-input');
  if (hiddenTaskField) {
    hiddenTaskField.value = currentTask;
  }
}

function getCurrentTask() {
  var selected = document.querySelector('input[name="taskOption"]:checked');
  if (selected && selected.value) {
    return selected.value;
  }
  return currentTask || 'detection';
}

function getFallbackModel() {
  return currentModel || 'yolov8n.pt';
}

syncTaskState(currentTask);

function closeWebRTCSingleSession(session, hideVideo) {
  if (!session) {
    return;
  }

  try {
    if (session.pc) {
      session.pc.ontrack = null;
      session.pc.onconnectionstatechange = null;
      session.pc.close();
    }
  } catch (err) {
    console.warn('Peer close failed', err);
  }

  if (session.localStream && session.manageTracks !== false) {
    session.localStream.getTracks().forEach(function(track) {
      try {
        track.stop();
      } catch (err) {
        console.warn('track stop error', err);
      }
    });
  }

  if (session.remoteVideo) {
    try {
      session.remoteVideo.pause();
    } catch (err) {}
    session.remoteVideo.srcObject = null;
    if (hideVideo) {
      session.remoteVideo.style.display = 'none';
    }
  }
}

function updateWebrtcStatus(message, level) {
  var box = document.getElementById('webrtc-inline-status');
  if (!box) {
    return;
  }
  if (!message) {
    box.style.display = 'none';
    box.textContent = '';
    box.className = 'alert alert-info';
    return;
  }
  box.textContent = message;
  box.className = 'alert alert-' + (level || 'info');
  box.style.display = 'block';
}

function showWebrtcErrorModal(message) {
  var content = document.getElementById('webrtc-error-message');
  if (content) {
    content.textContent = message || 'An unexpected error occurred while starting the WebRTC stream.';
  }
  if (window.jQuery && jQuery('#webrtc-error-modal').modal) {
    jQuery('#webrtc-error-modal').modal('show');
  } else {
    window.alert(message || 'An unexpected error occurred while starting the WebRTC stream.');
  }
}

function hideRemoteVideos() {
  var primary = document.getElementById('webrtc-remote');
  if (primary) {
    try { primary.pause(); } catch (err) {}
    primary.srcObject = null;
    primary.style.display = 'none';
  }
  var secondary = document.getElementById('webrtc-remote-secondary');
  if (secondary) {
    try { secondary.pause(); } catch (err) {}
    secondary.srcObject = null;
    secondary.style.display = 'none';
  }
}

function resetResultOutputs() {
  var img = document.getElementById('result-display');
  if (img) {
    try { img.src = ''; } catch (err) {}
    img.style.display = 'none';
  }

  var streamImg = document.getElementById('result-stream-display');
  if (streamImg) {
    try { streamImg.src = ''; } catch (err) {}
    streamImg.style.display = 'none';
  }

  var videoDisplay = document.getElementById('result-video-display');
  if (videoDisplay) {
    var videoSource = document.getElementById('result-video-source');
    if (videoSource) {
      try { videoSource.src = ''; } catch (err) {}
    }
    try { videoDisplay.load(); } catch (err) {}
    videoDisplay.style.display = 'none';
  }

  var vimg = document.getElementById('video-display');
  if (vimg) {
    vimg.onload = null;
    try { vimg.src = ''; } catch (err) {}
    vimg.style.display = 'none';
  }
}

function stopWebRTCSession(silent) {
  webrtcManager.closeAll(true);
  hideRemoteVideos();

  if (!silent) {
    updateWebrtcStatus('WebRTC session closed.', 'info');
  } else {
    updateWebrtcStatus('', 'info');
  }

  var stopBtn = document.getElementById('stop-btn');
  if (stopBtn) {
    stopBtn.style.display = 'none';
  }
}

async function getVideoInputs() {
  if (!navigator.mediaDevices || !navigator.mediaDevices.enumerateDevices) {
    return [];
  }
  var devices = await navigator.mediaDevices.enumerateDevices();
  return devices.filter(function(d) { return d.kind === 'videoinput'; });
}

async function getDeviceIdForIndex(camIndex) {
  async function ensureDevices() {
    var videos = await getVideoInputs();
    if (videos.length) {
      return videos;
    }

    try {
      var temp = await navigator.mediaDevices.getUserMedia({ video: true, audio: false });
      temp.getTracks().forEach(function(track) { track.stop(); });
    } catch (err) {
      console.warn('Temporary camera access failed:', err);
      return [];
    }

    return await getVideoInputs();
  }

  var videos = await ensureDevices();
  if (!videos.length) {
    return null;
  }

  if (typeof camIndex === 'number' && camIndex >= 0 && camIndex < videos.length && videos[camIndex].deviceId) {
    return videos[camIndex].deviceId;
  }

  return videos[0].deviceId || null;
}

async function startSingleWebRTCSession(model, deviceId, remoteVideo, onFirstFrame, options) {
  options = options || {};
  var taskName = options.task || getCurrentTask();
  var PeerConnection = window.RTCPeerConnection || window.webkitRTCPeerConnection || window.mozRTCPeerConnection;

  if (!window.isSecureContext) {
    throw new Error('Browser blocked camera because this page is not served over HTTPS or localhost.');
  }

  if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
    throw new Error('Camera APIs unavailable. Ensure the site is served over HTTPS and camera permissions are allowed.');
  }

  if (!PeerConnection) {
    throw new Error('WebRTC peer connection is not supported in this browser.');
  }

  if (!remoteVideo) {
    throw new Error('Missing remote video element.');
  }

  remoteVideo.pause();
  remoteVideo.srcObject = null;
  remoteVideo.style.display = 'none';

  var localStream = options.localStream || null;
  var manageTracks = options.manageTracks !== false;

  if (!localStream) {
    // Allow the user to choose a capture scale to request lower resolutions
    var scale = 1.0;
    try {
      var el = document.getElementById('webrtc-capture-scale');
      if (el && el.value) {
        scale = parseFloat(el.value) || 1.0;
      }
    } catch (e) { /* ignore */ }

    // Map scale to a reasonable target resolution (width x height)
    var target = { width: 1280, height: 720 };
    if (scale >= 0.99) { target = { width: 1280, height: 720 }; }
    else if (scale >= 0.74) { target = { width: 960, height: 540 }; }
    else if (scale >= 0.49) { target = { width: 640, height: 360 }; }
    else { target = { width: 320, height: 180 }; }

    var constraints = { video: true, audio: false };
    if (deviceId) {
      constraints.video = { deviceId: { exact: deviceId }, width: { ideal: target.width }, height: { ideal: target.height } };
    } else {
      constraints.video = { width: { ideal: target.width }, height: { ideal: target.height } };
    }

    try {
      localStream = await navigator.mediaDevices.getUserMedia(constraints);
    } catch (err) {
      throw new Error('Camera access denied: ' + err.message);
    }
  }

  var pc = new PeerConnection();
  var session = { pc: pc, localStream: localStream, remoteVideo: remoteVideo, manageTracks: manageTracks };
  webrtcManager.add(session);

  localStream.getTracks().forEach(function(track) {
    pc.addTrack(track, localStream);
  });

  pc.ontrack = function(event) {
    if (event.streams && event.streams[0]) {
      remoteVideo.srcObject = event.streams[0];
    }
    remoteVideo.style.display = 'block';
    try { remoteVideo.play(); } catch (err) {}
    if (typeof onFirstFrame === 'function') {
      onFirstFrame();
    }
  };

  pc.onconnectionstatechange = function() {
    if (['failed', 'disconnected', 'closed'].includes(pc.connectionState)) {
      closeWebRTCSingleSession(session, false);
      webrtcManager.remove(session);
      updateWebrtcStatus('Connection ' + pc.connectionState + '. Stream stopped.', 'warning');
    }
  };

  try {
    var offer = await pc.createOffer();
    await pc.setLocalDescription(offer);

    // include selected capture scale in the offer so server can adapt processing
    var scaleVal = 1.0;
    try {
      var scaleEl = document.getElementById('webrtc-capture-scale');
      if (scaleEl && scaleEl.value) scaleVal = parseFloat(scaleEl.value) || 1.0;
    } catch (e) {}

    // attempt to apply constraints to the outgoing local track to request lower resolution
    try {
      if (localStream && localStream.getVideoTracks && localStream.getVideoTracks().length) {
        var vtrack = localStream.getVideoTracks()[0];
        if (vtrack && vtrack.applyConstraints) {
          var target = { width: 1280, height: 720 };
          if (scaleVal >= 0.99) { target = { width: 1280, height: 720 }; }
          else if (scaleVal >= 0.74) { target = { width: 960, height: 540 }; }
          else if (scaleVal >= 0.49) { target = { width: 640, height: 360 }; }
          else { target = { width: 320, height: 180 }; }
          try {
            await vtrack.applyConstraints({ width: { exact: target.width }, height: { exact: target.height } });
          } catch (err) {
            // exact may fail on some devices; try ideal
            try { await vtrack.applyConstraints({ width: { ideal: target.width }, height: { ideal: target.height } }); } catch (e) { }
          }
        }
      }
    } catch (e) {
      console.warn('applyConstraints failed', e);
    }

    var response = await fetch("{{ url_for('webrtc_offer') }}", {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ sdp: offer.sdp, type: offer.type, model: model, task: taskName, scale: scaleVal })
    });

    var payload = await response.json();
    if (!response.ok) {
      throw new Error(payload.error || 'WebRTC negotiation failed.');
    }

    await pc.setRemoteDescription(payload);
  } catch (err) {
    closeWebRTCSingleSession(session, true);
    webrtcManager.remove(session);
    throw err;
  }

  return session;
}

async function startDualWebRTCSession(model0, deviceId0, model1, deviceId1) {
  var remoteA = document.getElementById('webrtc-remote');
  var remoteB = document.getElementById('webrtc-remote-secondary');

  if (!remoteA || !remoteB) {
    throw new Error('Dual camera video elements not found.');
  }

  if (!deviceId0 || !deviceId1) {
    throw new Error('Unable to resolve two camera devices.');
  }

  hideRemoteVideos();

  var spinner = document.getElementById('result-spinner');
  var stopBtn = document.getElementById('stop-btn');
  var connected = 0;

  function handleFrame() {
    connected += 1;
    if (connected === 2) {
      if (spinner) {
        spinner.style.display = 'none';
      }
      if (stopBtn) {
        stopBtn.style.display = 'inline-block';
      }
      updateWebrtcStatus('Streaming dual WebRTC feeds.', 'success');
      setTimeout(function(){ updateWebrtcStatus('', 'info'); }, 3000);
    }
  }

  await Promise.all([
    startSingleWebRTCSession(model0, deviceId0, remoteA, handleFrame),
    startSingleWebRTCSession(model1, deviceId1, remoteB, handleFrame)
  ]);
}

async function startSplitWebRTCSession(model0, model1, camIndex) {
  var remoteA = document.getElementById('webrtc-remote');
  var remoteB = document.getElementById('webrtc-remote-secondary');
  var taskName = getCurrentTask();

  if (!remoteA || !remoteB) {
    throw new Error('Split view video elements not found.');
  }

  var deviceId = await getDeviceIdForIndex(camIndex);
  if (!deviceId) {
    throw new Error('Unable to access camera device for split view.');
  }

  hideRemoteVideos();

  var spinner = document.getElementById('result-spinner');
  var stopBtn = document.getElementById('stop-btn');
  var connected = 0;

  var baseStream;
  try {
    var constraints = { video: { deviceId: { exact: deviceId } }, audio: false };
    baseStream = await navigator.mediaDevices.getUserMedia(constraints);
  } catch (err) {
    throw new Error('Camera access denied for split view: ' + err.message);
  }

  var streamA = new MediaStream();
  var streamB = new MediaStream();
  baseStream.getVideoTracks().forEach(function(track) {
    streamA.addTrack(track);
    streamB.addTrack(track.clone());
  });

  function handleFrame() {
    connected += 1;
    if (connected === 2) {
      if (spinner) {
        spinner.style.display = 'none';
      }
      if (stopBtn) {
        stopBtn.style.display = 'inline-block';
      }
      updateWebrtcStatus('Streaming split WebRTC feeds.', 'success');
      setTimeout(function(){ updateWebrtcStatus('', 'info'); }, 3000);
    }
  }

  try {
    await Promise.all([
      startSingleWebRTCSession(model0, null, remoteA, handleFrame, { localStream: streamA, task: taskName }),
      startSingleWebRTCSession(model1, null, remoteB, handleFrame, { localStream: streamB, task: taskName })
    ]);
  } catch (err) {
    streamA.getTracks().forEach(function(track){ try { track.stop(); } catch (stopErr) { console.warn('stop streamA track failed', stopErr); } });
    streamB.getTracks().forEach(function(track){ try { track.stop(); } catch (stopErr) { console.warn('stop streamB track failed', stopErr); } });
    throw err;
  }
}

function showUploadedResult() {
  stopWebRTCSession(true);
  hideRemoteVideos();
  resetResultOutputs();

  var spinner = document.getElementById('result-spinner');
  if (spinner) {
    spinner.style.display = 'none';
  }

  if (server_image_url) {
    var img = document.getElementById('result-display');
    if (img) {
      img.src = server_image_url;
      img.style.display = 'block';
    }
    var stopBtn = document.getElementById('stop-btn');
    if (stopBtn) {
      stopBtn.style.display = 'inline-block';
    }
  }
  else if (server_video_stream_url) {
    // Display real-time streaming video from server
    var streamImg = document.getElementById('result-stream-display');
    if (streamImg) {
      streamImg.src = server_video_stream_url;
      streamImg.style.display = 'block';
    }
    var stopBtn = document.getElementById('stop-btn');
    if (stopBtn) {
      stopBtn.style.display = 'inline-block';
    }
  }
  else if (server_video_present && server_video_folder) {
    // Display processed video (fallback if no stream URL)
    var task = getCurrentTask();
    var baseUrl = '/display/' + server_video_folder + '/output.mp4?task=' + encodeURIComponent(task);
    var videoDisplay = document.getElementById('result-video-display');
    var videoSource = document.getElementById('result-video-source');
    if (videoDisplay && videoSource) {
      videoSource.src = baseUrl;
      videoDisplay.load();
      videoDisplay.style.display = 'block';
    }
    var stopBtn = document.getElementById('stop-btn');
    if (stopBtn) {
      stopBtn.style.display = 'inline-block';
    }
  }
}

// Show webcam configuration modal
function showWebcamModal() {
  // For inline workflow: select webcam input and pre-select models from main selection (if any)
  var sel = document.querySelector('input[name="model"]:checked');
  var selectedModel = sel ? sel.value : getFallbackModel();

  // Pre-select single/dual model radios to the chosen model where possible
  var singleRadio = document.querySelector('input[name="single_model"][value="' + selectedModel + '"]');
  if (singleRadio) singleRadio.checked = true;
  var d0 = document.querySelector('input[name="dual_model0"][value="' + selectedModel + '"]');
  if (d0) d0.checked = true;
  var d1 = document.querySelector('input[name="dual_model1"][value="' + selectedModel + '"]');
  if (d1) d1.checked = true;

  // Switch the inputType to webcam so webcam options become enabled
  var wb = document.getElementById('input-webcam');
  if (wb) { wb.checked = true; wb.dispatchEvent(new Event('change')); }

  // Scroll to webcam area for visibility
  var el = document.getElementById('webcam-options-area');
  if (el) el.scrollIntoView({ behavior: 'smooth', block: 'center' });
}

// Toggle dual camera options visibility
function toggleDualCameraOptions() {
  // Support legacy call and inline radio-driven mode.
  // If the user enabled the single-split checkbox, prefer showing the dual-model panels
  var splitCheckbox = document.getElementById('single_split_mode');
  var splitEnabled = splitCheckbox && splitCheckbox.checked;

  var modeRadio = document.querySelector('input[name="camera_mode"]:checked');
  var mode = modeRadio ? modeRadio.value : null;
  if (!mode) {
    // legacy fallback to select element
    var sel = document.getElementById('camera-mode-select');
    mode = sel ? sel.value : 'single';
  }

  if (splitEnabled) {
    // Show dual-model selectors so user can pick two models for the stacked single-camera view
    var s_hide = document.getElementById('webcam-models-single'); if (s_hide) s_hide.style.display = 'none';
    var d_show = document.getElementById('webcam-models-dual'); if (d_show) d_show.style.display = 'block';
    return;
  }

  if (mode === 'single') {
    var s = document.getElementById('webcam-models-single'); if (s) s.style.display = 'block';
    var d = document.getElementById('webcam-models-dual'); if (d) d.style.display = 'none';
  } else {
    var s2 = document.getElementById('webcam-models-single'); if (s2) s2.style.display = 'none';
    var d2 = document.getElementById('webcam-models-dual'); if (d2) d2.style.display = 'block';
  }
  // Enable the Start Webcam button if webcam input is selected
  var inputTypeWebcam = document.getElementById('input-webcam');
  if (inputTypeWebcam && inputTypeWebcam.checked) {
    var startBtn = document.getElementById('start-webcam-inline');
    if (startBtn) {
      startBtn.disabled = false;
      // ensure the button is visible inside the left panel (scroll to it)
      try { startBtn.scrollIntoView({ behavior: 'smooth', block: 'center' }); } catch(e){}
      // give a small attention highlight
      startBtn.style.boxShadow = '0 0 0.5rem rgba(220,53,69,0.25)';
      setTimeout(function(){ startBtn.style.boxShadow = ''; }, 1200);
    }
  }
}

function promptForCameraIndices(requiredCount) {
  requiredCount = Math.max(1, requiredCount || 1);
  return new Promise(function(resolve) {
    fetch('{{ url_for("list_cameras") }}').then(function(r){ return r.json(); }).then(function(data){
      var cams = (data && Array.isArray(data.cameras)) ? data.cameras.slice() : [];
      if (!cams.length) {
        resolve(requiredCount === 1 ? [0] : []);
        return;
      }

      if (cams.length <= requiredCount) {
        resolve(cams.slice(0, requiredCount));
        return;
      }

      var list = document.getElementById('camera-index-list');
      var modal = document.getElementById('camera-index-modal');
      var instructions = document.getElementById('camera-index-instructions');
      if (!list || !modal) {
        resolve(cams.slice(0, requiredCount));
        return;
      }

      list.innerHTML = '';

      var inputType = (requiredCount === 1) ? 'radio' : 'checkbox';
      var inputName = (requiredCount === 1) ? 'cam_index_single' : 'cam_index_multi';
      if (instructions) {
        instructions.textContent = (requiredCount === 1)
          ? 'Multiple cameras detected. Choose which camera to use:'
          : 'Multiple cameras detected. Select ' + requiredCount + ' cameras to use:';
      }

      cams.forEach(function(ci){
        var id = 'cam_select_' + ci;
        var wrapper = document.createElement('div');
        wrapper.className = 'form-check';
        wrapper.innerHTML = '<input class="form-check-input" type="' + inputType + '" name="' + inputName + '" id="' + id + '" value="' + ci + '">' +
                             '<label class="form-check-label small" for="' + id + '">Camera ' + ci + '</label>';
        list.appendChild(wrapper);
      });

      var chooseBtn = document.getElementById('camera-index-choose');
      var cancelBtn = document.getElementById('camera-index-cancel');
      var resolved = false;

      function cleanup(result) {
        if (resolved) {
          return;
        }
        resolved = true;
        if (modal) {
          modal.style.display = 'none';
        }
        if (chooseBtn) {
          chooseBtn.onclick = null;
        }
        if (cancelBtn) {
          cancelBtn.onclick = null;
        }
        resolve(result);
      }

      function enforceSelectionState() {
        if (!chooseBtn || inputType === 'radio') {
          return;
        }
        var checked = list.querySelectorAll('input[type="checkbox"]:checked').length;
        chooseBtn.disabled = checked !== requiredCount;
      }

      if (chooseBtn) {
        chooseBtn.disabled = (inputType === 'checkbox');
        chooseBtn.onclick = function() {
          var selected = [];
          var selector = 'input[name="' + inputName + '"]' + (inputType === 'checkbox' ? ':checked' : ':checked');
          list.querySelectorAll(selector).forEach(function(el){
            var val = parseInt(el.value, 10);
            if (!Number.isNaN(val)) {
              selected.push(val);
            }
          });

          if (inputType === 'radio' && !selected.length) {
            selected.push(cams[0]);
          }

          if (inputType === 'checkbox' && selected.length !== requiredCount) {
            return;
          }

          cleanup(selected.slice(0, requiredCount));
        };
      }

      if (cancelBtn) {
        cancelBtn.onclick = function() {
          cleanup(cams.slice(0, requiredCount));
        };
      }

      if (inputType === 'radio') {
        var first = list.querySelector('input[type="radio"]');
        if (first) {
          first.checked = true;
        }
      } else {
        list.querySelectorAll('input[type="checkbox"]').forEach(function(el){
          el.addEventListener('change', enforceSelectionState);
        });
      }

      enforceSelectionState();
      modal.style.display = 'block';
    }).catch(function() {
      resolve(requiredCount === 1 ? [0] : []);
    });
  });
}

function promptForCameraIndex() {
  return promptForCameraIndices(1).then(function(indices) {
    return (indices && indices.length) ? indices[0] : 0;
  });
}

async function startSelectedWebcam() {
  var modeRadio = document.querySelector('input[name="camera_mode"]:checked');
  var mode = modeRadio ? modeRadio.value : (document.getElementById('camera-mode-select') ? document.getElementById('camera-mode-select').value : 'single');
  var spinner = document.getElementById('result-spinner');
  var spinnerText = document.getElementById('spinner-text');
  var img = document.getElementById('result-display');
  var vimg = document.getElementById('video-display');
  var fallbackModel = getFallbackModel();

  stopWebRTCSession(true);
  hideRemoteVideos();
  resetResultOutputs();

  if (img) {
    img.style.display = 'none';
  }
  if (vimg) {
    vimg.style.display = 'none';
  }

  if (spinner) {
    spinner.style.display = 'block';
  }
  if (spinnerText) {
    spinnerText.textContent = mode === 'single' ? 'Initializing camera and loading model...' : 'Initializing cameras and loading models...';
  }

  var fallbackModel = null;
  var fallbackCamIndex = 0;
  var fallbackModel0 = null;
  var fallbackModel1 = null;
  var splitModeRequested = false;

  try {
    if (mode === 'single') {
      var singleSplitCheckbox = document.getElementById('single_split_mode');
      var isSplit = singleSplitCheckbox && singleSplitCheckbox.checked;
      if (isSplit) {
        var splitModel0Radio = document.querySelector('input[name="dual_model0"]:checked');
        var splitModel1Radio = document.querySelector('input[name="dual_model1"]:checked');
        var splitModel0 = splitModel0Radio ? splitModel0Radio.value : fallbackModel;
        var splitModel1 = splitModel1Radio ? splitModel1Radio.value : fallbackModel;
        var splitCamIndex = await promptForCameraIndex();
        splitModeRequested = true;
        fallbackModel0 = splitModel0;
        fallbackModel1 = splitModel1;
        fallbackCamIndex = splitCamIndex;
        if (spinnerText) {
          spinnerText.textContent = 'Negotiating split WebRTC sessions...';
        }
        updateWebrtcStatus('Negotiating split WebRTC sessions...', 'info');
        await startSplitWebRTCSession(splitModel0, splitModel1, splitCamIndex);
        return;
      }

      var selModel = document.querySelector('input[name="single_model"]:checked');
      var model = selModel ? selModel.value : fallbackModel;
      fallbackModel = model;

      var camIndex = await promptForCameraIndex();
      fallbackCamIndex = camIndex;
      var deviceId = await getDeviceIdForIndex(camIndex);
      var remoteVideo = document.getElementById('webrtc-remote');
      if (!remoteVideo) {
        throw new Error('Missing remote video element.');
      }

      updateWebrtcStatus('Negotiating WebRTC session...', 'info');
      await startSingleWebRTCSession(model, deviceId, remoteVideo, function() {
        if (spinner) {
          spinner.style.display = 'none';
        }
        var stopBtn = document.getElementById('stop-btn');
        if (stopBtn) {
          stopBtn.style.display = 'inline-block';
        }
        updateWebrtcStatus('Streaming via WebRTC.', 'success');
        setTimeout(function(){ updateWebrtcStatus('', 'info'); }, 3000);
      });
    } else {
      var dualModel0Radio = document.querySelector('input[name="dual_model0"]:checked');
      var dualModel1Radio = document.querySelector('input[name="dual_model1"]:checked');
      var model0 = dualModel0Radio ? dualModel0Radio.value : fallbackModel;
      var model1 = dualModel1Radio ? dualModel1Radio.value : fallbackModel;
      fallbackModel0 = model0;
      fallbackModel1 = model1;

      var camSelection = await promptForCameraIndices(2);
      if (!Array.isArray(camSelection) || camSelection.length < 2) {
        throw new Error('At least two cameras are required for dual mode.');
      }

      var deviceId0 = await getDeviceIdForIndex(camSelection[0]);
      var deviceId1 = await getDeviceIdForIndex(camSelection[1]);

      if (!deviceId0 || !deviceId1) {
        throw new Error('Unable to find two camera devices for dual mode.');
      }

      if (deviceId0 === deviceId1) {
        throw new Error('Selected cameras resolve to the same device. Pick two distinct cameras.');
      }

      if (spinnerText) {
        spinnerText.textContent = 'Negotiating WebRTC sessions...';
      }
      updateWebrtcStatus('Negotiating dual WebRTC sessions...', 'info');
      await startDualWebRTCSession(model0, deviceId0, model1, deviceId1);
    }
  } catch (err) {
    console.error('WebRTC start failed:', err);
    var message = err && err.message ? err.message : 'unknown error';

    if (spinner) {
      spinner.style.display = 'none';
    }
    var stopBtn = document.getElementById('stop-btn');
    if (stopBtn) {
      stopBtn.style.display = 'none';
    }

    stopWebRTCSession(true);
    hideRemoteVideos();

    if (spinnerText) {
      spinnerText.textContent = 'Failed to start WebRTC session.';
    }

    var errorContext;
    if (mode === 'single' && splitModeRequested) {
      errorContext = 'Split WebRTC failed: ' + message;
    } else if (mode === 'single' && fallbackModel !== null) {
      errorContext = 'WebRTC negotiation failed: ' + message;
    } else if (mode === 'dual') {
      errorContext = 'Dual WebRTC failed: ' + message;
    } else {
      errorContext = 'Unable to start webcam: ' + message;
    }

    updateWebrtcStatus(errorContext, 'danger');
    showWebrtcErrorModal(errorContext);
  }
}

// Start webcam stream into the result area (kept for backward compatibility)
function startWebcam() {
  showWebcamModal();
}

// Stop any stream and clear the result area (works for image, processed video or webcam)
function stopStream() {
  stopWebRTCSession(true);
  hideRemoteVideos();
  resetResultOutputs();

  var spinner = document.getElementById('result-spinner');
  var spinnerText = document.getElementById('spinner-text');
  if (spinner) {
    spinner.style.display = 'none';
  }
  if (spinnerText) {
    spinnerText.textContent = 'Processing, please wait...';
  }
  updateWebrtcStatus('', 'info');
}

document.getElementById('stop-btn').addEventListener('click', function(e){
  // Prevent default (in case button resides in a form) so it doesn't submit and reload the page
  try { e.preventDefault(); } catch(err){}
  // Close button: only stop the stream / clear outputs. Do not navigate to Home.
  stopStream();
});

// If the server provided a processed image path, show it on load
window.addEventListener('load', function(){
  showUploadedResult();
  // If server returned a processed image, video stream, or video file, show the Detection dashboard so the user sees results immediately.
  try {
    var hasImage = (typeof server_image_url !== 'undefined' && server_image_url);
    var hasVideoStream = (typeof server_video_stream_url !== 'undefined' && server_video_stream_url);
    var hasVideo = (typeof server_video_present !== 'undefined' && server_video_present === true);
    if (hasImage || hasVideoStream || hasVideo) {
      showDetectionView();
    } else {
      var taskNow = getCurrentTask();
      if (taskNow === 'detection' || taskNow === 'segmentation' || taskNow === 'pose') {
        hideUnavailable();
        showDetectionView();
      } else {
        showHomeView();
      }
    }
  } catch(e) { try { showHomeView(); } catch(err){} }
});

// Navigation and Tasks wiring: show/hide home and detection views
function showHomeView(){
  var home = document.getElementById('home-view');
  var det = document.getElementById('detection-dashboard');
  var contact = document.getElementById('contact-view');
  if (home) home.style.display = 'block';
  if (det) det.style.display = 'none';
  if (contact) contact.style.display = 'none';
}

function showDetectionView(){
  var home = document.getElementById('home-view');
  var det = document.getElementById('detection-dashboard');
  var contact = document.getElementById('contact-view');
  if (home) home.style.display = 'none';
  if (det) det.style.display = 'block';
  if (contact) contact.style.display = 'none';
  // scroll to top of detection area
  try { window.scrollTo({ top: 0, behavior: 'smooth' }); } catch(e){}
}

function showContactView(){
  var home = document.getElementById('home-view');
  var det = document.getElementById('detection-dashboard');
  var contact = document.getElementById('contact-view');
  if (home) home.style.display = 'none';
  if (det) det.style.display = 'none';
  if (contact) contact.style.display = 'block';
  try { window.scrollTo({ top: 0, behavior: 'smooth' }); } catch(e){}
}

function showUnavailable(task){
  var home = document.getElementById('home-view');
  var det = document.getElementById('detection-dashboard');
  var content = document.getElementById('detection-content');
  var ua = document.getElementById('task-unavailable');
  if (home) home.style.display = 'none';
  if (det) det.style.display = 'block';
  if (content) content.style.display = 'none';
  if (ua) {
    var name = task || '';
    var label = document.getElementById('unavailable-task-name');
    if (label) label.textContent = name.charAt(0).toUpperCase() + name.slice(1);
    ua.style.display = 'block';
  }
}

function hideUnavailable(){
  var content = document.getElementById('detection-content');
  var ua = document.getElementById('task-unavailable');
  var contact = document.getElementById('contact-view');
  if (ua) ua.style.display = 'none';
  if (content) content.style.display = 'block';
  if (contact) contact.style.display = 'none';
}

// Wire nav links and task radio buttons after DOM is ready
document.addEventListener('DOMContentLoaded', function(){
  var homeLink = document.getElementById('nav-home');
  var contactLink = document.getElementById('nav-contact');
  if (homeLink) homeLink.addEventListener('click', function(e){ e.preventDefault(); showHomeView(); });
  if (contactLink) contactLink.addEventListener('click', function(e){ e.preventDefault(); showContactView(); });

  // Task radio selection: reload for implemented tasks, show placeholder otherwise
  var taskRadios = document.querySelectorAll('input[name="taskOption"]');
  var initialTask = currentTask;

  syncTaskState(initialTask);

  taskRadios.forEach(function(radio) {
    if (radio.value === initialTask) {
      radio.checked = true;
    }

    radio.addEventListener('change', function() {
      if (!this.checked) {
        return;
      }

      var selectedValue = this.value;
      syncTaskState(selectedValue);

      if (selectedValue === 'detection' || selectedValue === 'segmentation' || selectedValue === 'pose') {
        hideUnavailable();
        showDetectionView();

        if (selectedValue !== initialTask) {
          try {
            var targetUrl = new URL(window.location.href);
            targetUrl.searchParams.set('task', selectedValue);
            targetUrl.searchParams.delete('model');
            window.location.href = targetUrl.toString();
          } catch (err) {
            window.location.href = window.location.pathname + '?task=' + encodeURIComponent(selectedValue);
          }
        }
      } else {
        showUnavailable(selectedValue);
      }
    });
  });

  var primaryModelRadios = document.querySelectorAll('input[name="model"]');
  primaryModelRadios.forEach(function(radio) {
    radio.addEventListener('change', function() {
      if (this.checked) {
        currentModel = this.value;
      }
    });
  });

    // Wire unavailable OK button
    var okBtn = document.getElementById('unavailable-ok');
    if (okBtn) okBtn.addEventListener('click', function(){ hideUnavailable(); showHomeView(); });
});

// Show spinner when user submits the predict form
document.getElementById('predict-form').addEventListener('submit', function(e){
  // clear previous results
  try { document.getElementById('result-display').src = ''; } catch(e) {}
  try { document.getElementById('video-display').src = ''; } catch(e) {}
  document.getElementById('result-display').style.display = 'none';
  document.getElementById('video-display').style.display = 'none';
  // show spinner
  var spinner = document.getElementById('result-spinner');
  if (spinner) spinner.style.display = 'block';
});

// Inline UI wiring: enable/disable controls based on selections
(function(){
  // inputType radios
  var inputRadios = document.querySelectorAll('input[name="inputType"]');
  var fileArea = document.getElementById('file-input-area');
  var fileHint = document.getElementById('file-input-hint');
  var webcamArea = document.getElementById('webcam-options-area');
  var fileInput = document.getElementById('inputfile');
  var startBtn = document.getElementById('start-webcam-inline');
  var predictBtn = document.getElementById('predict-btn');

  function showElement(el, shouldShow) {
    if (!el) {
      return;
    }
    el.style.display = shouldShow ? '' : 'none';
  }

  inputRadios.forEach(function(r){ r.addEventListener('change', function(){
    var val = document.querySelector('input[name="inputType"]:checked').value;

    if (val === 'image' || val === 'video'){
      if (fileInput) {
        fileInput.disabled = false;
        fileInput.value = '';
      }
      if (predictBtn) {
        predictBtn.disabled = true;
        predictBtn.classList.remove('btn-danger');
        predictBtn.classList.add('btn-secondary');
        predictBtn.textContent = 'Predict';
        showElement(predictBtn, true);
      }
      if (startBtn) {
        startBtn.disabled = true;
        showElement(startBtn, false);
      }
      if (fileHint) {
        fileHint.textContent = (val === 'image')
          ? 'Upload an image file for detection (PNG, JPG, JPEG, BMP, GIF, WebP).'
          : 'Upload a video file for frame-by-frame inference (MP4, AVI, MOV, MKV, FLV, WMV).';
        fileHint.style.display = 'block';
      }
      showElement(fileArea, true);
      showElement(webcamArea, false);
    } else if (val === 'webcam'){
      if (fileInput) {
        fileInput.disabled = true;
        fileInput.value = '';
      }
      if (predictBtn) {
        predictBtn.disabled = true;
        predictBtn.classList.remove('btn-danger');
        predictBtn.classList.add('btn-secondary');
        predictBtn.textContent = 'Predict';
        showElement(predictBtn, false);
      }
      if (startBtn) {
        startBtn.disabled = false;
        try {
          startBtn.scrollIntoView({ behavior: 'smooth', block: 'center' });
        } catch (err) {}
        startBtn.style.boxShadow = '0 0 0.5rem rgba(220,53,69,0.25)';
        setTimeout(function(){ startBtn.style.boxShadow = ''; }, 1200);
        showElement(startBtn, true);
      }
      if (fileHint) {
        fileHint.style.display = 'none';
      }
      showElement(fileArea, false);
      showElement(webcamArea, true);
      // Ensure webcam mode sections reflect current toggles
      try { toggleDualCameraOptions(); } catch (err) {}
    }
  }); });

  var presetInput = document.querySelector('input[name="inputType"]:checked');
  if (presetInput) {
    presetInput.dispatchEvent(new Event('change'));
  } else {
    showElement(fileArea, false);
    showElement(webcamArea, false);
    showElement(predictBtn, false);
    showElement(startBtn, false);
    if (fileHint) {
      fileHint.style.display = 'none';
    }
  }

  // file input change -> enable Predict
    if (fileInput){
    fileInput.addEventListener('change', function(){
      var btn = document.getElementById('predict-btn');
      if (this.files && this.files.length > 0){ 
        btn.disabled = false; 
        // Make the button visually prominent when enabled
        btn.classList.remove('btn-secondary');
        btn.classList.add('btn-danger');
        btn.textContent = 'Detect';
        // bring button into view
        try { btn.scrollIntoView({behavior:'smooth', block:'center'}); } catch(e){}
      }
      else { 
        btn.disabled = true; 
        btn.classList.remove('btn-danger');
        btn.classList.add('btn-secondary');
        btn.textContent = 'Predict';
      }
    });
  }

  // camera mode change -> show/hide dual panels
  var camRadios = document.querySelectorAll('input[name="camera_mode"]');
  camRadios.forEach(function(r){ r.addEventListener('change', function(){ toggleDualCameraOptions(); }); });

  // When user toggles the single-split checkbox, show the dual-model selectors so they can pick two models
  var splitCheckbox = document.getElementById('single_split_mode');
  if (splitCheckbox) {
    splitCheckbox.addEventListener('change', function(){
      var dual = document.getElementById('webcam-models-dual');
      var single = document.getElementById('webcam-models-single');
      if (this.checked) {
        if (dual) dual.style.display = 'block';
        if (single) single.style.display = 'none';
        // ensure at least one radio is checked for both dual_model0 and dual_model1
        var a = document.querySelector('input[name="dual_model0"]:checked');
        if (!a) { var first = document.querySelector('input[name="dual_model0"]'); if (first) first.checked = true; }
        var b = document.querySelector('input[name="dual_model1"]:checked');
        if (!b) { var first2 = document.querySelector('input[name="dual_model1"]'); if (first2) first2.checked = true; }
      } else {
        if (dual) dual.style.display = 'none';
        if (single) single.style.display = 'block';
      }
    });
  }

  // single-split checkbox -> show dual-model selectors even when camera mode is single
  var singleSplit = document.getElementById('single_split_mode');
  if (singleSplit) {
    singleSplit.addEventListener('change', function(){
      // When enabling split mode, ensure webcam input is selected so Start Webcam is available
      try { document.getElementById('input-webcam').checked = true; } catch(e){}
      toggleDualCameraOptions();
    });
  }

  // Upload model button handler (AJAX)
  var uploadBtn = document.getElementById('upload-model-submit');
  if (uploadBtn){
    uploadBtn.addEventListener('click', function(){
      if(!document.getElementById('disclaimer_inline').checked){ alert('Please confirm you have the rights to upload this model.'); return; }
      var file = document.getElementById('model_file');
      if(!file || !file.files || file.files.length===0){ alert('Please select a .pt model file to upload.'); return; }
      var fd = new FormData();
      fd.append('model_file', file.files[0]);
      fd.append('model_name', document.getElementById('model_name').value || '');
      fd.append('disclaimer', document.getElementById('disclaimer_inline').checked ? 'on' : '');
      fd.append('task', getCurrentTask());
      uploadBtn.disabled = true; uploadBtn.textContent = 'Uploading...';
      fetch('/upload_model', { method: 'POST', body: fd }).then(function(r){ return r.text(); }).then(function(){ location.reload(); }).catch(function(err){ alert('Upload failed: '+err); uploadBtn.disabled=false; uploadBtn.textContent='Upload'; });
    });
  }
  // Wire Start Webcam inline button to existing startSelectedWebcam function
  var startInline = document.getElementById('start-webcam-inline');
  if (startInline) startInline.addEventListener('click', function(){
    startSelectedWebcam().catch(function(err){
      console.error('Failed to start webcam', err);
      var message = err && err.message ? err.message : err;
      var finalMessage = 'Unable to start webcam: ' + message;
      updateWebrtcStatus(finalMessage, 'danger');
      showWebrtcErrorModal(finalMessage);
      var spinner = document.getElementById('result-spinner');
      if (spinner) {
        spinner.style.display = 'none';
      }
    });
  });

})();
</script>


<!-- AI code ends here-->		

                    </div>
                 
                </div>
              </div><!-- /.card-body -->
            </div>
            <!-- /.card -->

            
      
          </section>
		  
		  
		  
          <!-- /.Left col -->
          <!-- right col (We are only adding the ID to make the widgets sortable)-->

          <!-- right col -->
  </div>
  </div> <!-- /#detection-content -->
  </div>
  </div> <!-- /#detection-dashboard -->
        <!-- /.row (main row) -->
      </div><!-- /.container-fluid -->
    </section>
    <!-- /.content -->

  </div>

{% endblock content %}

<!-- Specific Page JS goes HERE  -->
{% block javascripts %}

  <!-- jQuery -->
  <script src="/static/assets/plugins/jquery/jquery.min.js"></script>
  <!-- jQuery UI 1.11.4 -->
  <script src="/static/assets/plugins/jquery-ui/jquery-ui.min.js"></script>
  <!-- Resolve conflict in jQuery UI tooltip with Bootstrap tooltip -->
  <script>
    $.widget.bridge('uibutton', $.ui.button)
  </script>
  <!-- Bootstrap 4 -->
  <script src="/static/assets/plugins/bootstrap/js/bootstrap.bundle.min.js"></script>
  <!-- ChartJS -->
  <script src="/static/assets/plugins/chart.js/Chart.min.js"></script>
  <!-- Sparkline -->
  <script src="/static/assets/plugins/sparklines/sparkline.js"></script>
  <!-- JQVMap -->
  <script src="/static/assets/plugins/jqvmap/jquery.vmap.min.js"></script>
  <script src="/static/assets/plugins/jqvmap/maps/jquery.vmap.usa.js"></script>
  <!-- jQuery Knob Chart -->
  <script src="/static/assets/plugins/jquery-knob/jquery.knob.min.js"></script>
  <!-- daterangepicker -->
  <script src="/static/assets/plugins/moment/moment.min.js"></script>
  <script src="/static/assets/plugins/daterangepicker/daterangepicker.js"></script>
  <!-- Tempusdominus Bootstrap 4 -->
  <script src="/static/assets/plugins/tempusdominus-bootstrap-4/js/tempusdominus-bootstrap-4.min.js"></script>
  <!-- Summernote -->
  <script src="/static/assets/plugins/summernote/summernote-bs4.min.js"></script>
  <!-- overlayScrollbars -->
  <script src="/static/assets/plugins/overlayScrollbars/js/jquery.overlayScrollbars.min.js"></script>
  <!-- AdminLTE App -->
  <script src="/static/assets/js/adminlte.js"></script>
  <!-- AdminLTE dashboard demo (This is only for demo purposes) -->
  <script src="/static/assets/js/pages/dashboard.js"></script>
  <!-- AdminLTE for demo purposes -->
  <script src="/static/assets/js/demo.js"></script>
  <!-- Intro.js library -->
  <script src="https://unpkg.com/intro.js/minified/intro.min.js"></script>

  <script>
    // Guided tour: show prompt if user hasn't seen the tour or if forced by URL (?tour=1)
    (function(){
      function onReady(fn){ if (document.readyState !== 'loading') fn(); else document.addEventListener('DOMContentLoaded', fn); }
      onReady(function(){
        try {
          var seen = localStorage.getItem('dashboard_tour_seen');
          var prompt = document.getElementById('tour-prompt');
          var startBtn = document.getElementById('tour-start');
          var skipBtn = document.getElementById('tour-skip');
          var helpBtn = document.getElementById('tour-help-btn');
          var toast = document.getElementById('tour-toast');
          var toastStart = document.getElementById('tour-toast-start');
          var toastDismiss = document.getElementById('tour-toast-dismiss');

          // check URL param 'tour=1' to force display
          var urlParams = new URLSearchParams(window.location.search);
          var force = urlParams.get('tour') === '1';

          if ((!seen && prompt) || force){
            // show prompt after short delay
            setTimeout(function(){ if (prompt) prompt.style.display = 'block'; }, 500);
          } else if (seen && !localStorage.getItem('dashboard_tour_skipped')){
            // user previously saw tour  show a gentle toast reminder for a short time
            if (toast){ toast.style.display = 'block'; setTimeout(function(){ try{ toast.style.display='none'; }catch(e){} }, 15000); }
          }

          function markSeen(){ localStorage.setItem('dashboard_tour_seen', '1'); if (prompt) prompt.style.display='none'; }

          function startTour(){
            markSeen();
            var candidateSteps = [
              { selector: '#model-list', text: 'Step 1: Choose a model from the visible list or upload a custom .pt model.', position: 'bottom' },
              { selector: '#model_file', text: 'You can upload a custom .pt model here (it is loaded into memory only).', position: 'bottom' },
              { selector: '#input-image', text: 'Step 2: Select the input type: Image, Video, or Webcam.', position: 'bottom' },
              { selector: '#file-input-area', text: 'If you selected Image or Video, pick a file here and press predict buttom.', position: 'bottom' },
              { selector: '#webcam-options-area', text: 'If Webcam is selected, choose single or dual camera and per-camera models here.', position: 'bottom' },
              { selector: '#start-webcam-inline', text: 'Start the webcam stream inline on the right side.', position: 'bottom' },
              { selector: '#predict-btn', text: 'Click Detect to run the selected model on the uploaded file.', position: 'bottom' },
              { selector: '#result-display', text: 'Results (images/videos/streams) show here on the right.', position: 'top' }
            ];

            var steps = [];
            candidateSteps.forEach(function(s){
              try {
                var el = document.querySelector(s.selector);
                // If element exists but is hidden (display:none), try to use a visible right-side container
                var isVisible = el && el.offsetParent !== null && window.getComputedStyle(el).display !== 'none' && window.getComputedStyle(el).visibility !== 'hidden';
                if (el && isVisible) {
                  steps.push({ element: el, intro: s.text, position: s.position });
                } else if (s.selector === '#result-display') {
                  // prefer the right-result container as anchor for the results step
                  var alt = document.querySelector('.right-result-container');
                  if (alt) {
                    steps.push({ element: alt, intro: s.text, position: 'left' });
                  } else {
                    steps.push({ intro: s.text });
                  }
                } else if (el && !isVisible) {
                  // element present but hidden: show a center step instead so the user still sees guidance
                  steps.push({ intro: s.text });
                } else {
                  // element not present: add a center step showing the text so the flow continues
                  steps.push({ intro: s.text });
                }
              } catch(e){ steps.push({ intro: s.text }); }
            });

            // Hide the built-in skip button and label  we provide our own prompt controls
            introJs().setOptions({ steps: steps, showProgress: true, exitOnOverlayClick: false, showBullets: false, nextLabel:'Next', prevLabel:'Back', doneLabel:'Done', skipLabel:'', showSkipButton: false }).start();
          }

          if (startBtn){ startBtn.addEventListener('click', startTour); }
          if (skipBtn){ skipBtn.addEventListener('click', markSeen); }
          if (helpBtn){ helpBtn.addEventListener('click', function(){ startTour(); }); }
          if (toastStart){ toastStart.addEventListener('click', function(){ startTour(); if (toast) toast.style.display='none'; }); }
          if (toastDismiss){ toastDismiss.addEventListener('click', function(){ if (toast) toast.style.display='none'; localStorage.setItem('dashboard_tour_skipped','1'); }); }
        } catch (e){ console.warn('Tour init failed', e); }
      });
    })();
  </script>

{% endblock javascripts %}
